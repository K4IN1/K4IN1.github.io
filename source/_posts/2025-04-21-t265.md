---
title: 使用T265在rtabmap中定位建图
date: 2025-04-21 23:20:42
tags: 
- Realsense
- T265
- SLAM
categories:
- 教程
---
# T265 On Rtabmap

如何在rtabmap中使用T265建图

## RealsenseSDK与ROS

从源码安装即可，SDK选择  
> RealSense ROS v2.3.1  
> Built with LibRealSense v2.48.0   

测试是兼容的，注意下不要选择版本过高，否则T265的支持会掉
另外通过修改改源码的方式也可以提供原来版本的同步时间戳功能


## Odom

可以使用内置的方法，但我配置了半天没弄明白它的矫正和TF树，所以使用外置的其他VIO，如OPENVINS  
OpenVINS的Odom追踪在IMU的LINK上，同时包含了一个cam0和cam1的固定变化  
启动方式如下:

首先启动T265节点，需要指定IMU差值方法，并且enable两个鱼眼镜头，反而是pose这个topic不是很需要  
  
``` bash
roslaunch realsense2_camera rs_t265.launch unite_imu_method:=linear_interpolation
```

> 建议是直接改这个launch文件，然后记住topic的NAME_SPACE  
> 比如我这里使用camera  

随后启动VINS

``` bash
roslaunch ov_msckf t265_openvins.launch
```

> 这个launch是我自己修改的，也给这个节点本身的源码添加了几个rosparam，记得要在config对应的配置文件修改topicname使其符合t265的topic  

然后动一下相机，激活vins，这样才能让global树发送出来

## 矫正图像

### 发布正确的camerainfo

原始的camerainfo为D[5]，鱼眼相机模型应该是D[4]，会导致节点报错，但我又不是从源码编译的这个节点，所以写一个python脚本发布

```python
#!/usr/bin/env python
import rospy
from sensor_msgs.msg import Image
from sensor_msgs.msg import CameraInfo
import yaml

def loadCalibrationFile(filename, cname):
    ci = CameraInfo()

    f = open(filename)
    calib = yaml.load(f)
    if calib is not None:
        ci.width = calib['image_width']
        ci.height = calib['image_height']
        ci.distortion_model = calib['distortion_model']
        ci.D = calib['distortion_coefficients']['data']
        ci.K = calib['camera_matrix']['data']
        ci.R = calib['rectification_matrix']['data']
        ci.P = calib['projection_matrix']['data']

    return ci

def callback(data):
    info.header = data.header
    #　info.header.frame_id = 'camera_fisheye1_optical_frame'
    pub.publish(info)
    
if __name__ == '__main__':
    rospy.init_node('camera_info_pub', anonymous=True)
    url = rospy.get_param('~url')
    info = loadCalibrationFile(url, '')
    print(info)
    pub = rospy.Publisher('camera_info', CameraInfo, queue_size=1)
    rospy.Subscriber("image", Image, callback)
    rospy.spin()
```

运行的时候记得加上对应url

```bash
python3 camera_info_pub1.py \ 
image:=/camera/fisheye1/image_raw    \
camera_info:=/camera/fisheye1/camera_info_calib \ 
_url:=./t265_left_1.yaml 
```

另一个bash

```bash
python3 camera_info_pub2.py \
_url:=./t265_right.yaml \
image:=/camera/fisheye2/image_raw    \
camera_info:=/camera/fisheye2/camera_info_calib

```

yaml的格式应该是如下

```yaml
camera_name: "905312112011_left"
image_width: 848
image_height: 800
camera_matrix:
   rows: 3
   cols: 3
   data: [ 2.8845847407434218e+02, 0., 4.2366155337303530e+02, 0.,
       2.8732351128054398e+02, 4.0774252018099634e+02, 0., 0., 1. ]
distortion_coefficients:
   rows: 1
   cols: 4
   data: [ 1.6108401660058620e-02, -1.5462775664278158e-02,
       9.5501371240367117e-03, -6.7432882743460659e-03 ]
distortion_model: equidistant
rectification_matrix:
   rows: 3
   cols: 3
   data: [ 9.9996361896819130e-01, 1.0752140026281053e-03,
       -8.4619533729723070e-03, -1.0848458428058135e-03,
       9.9999876886529271e-01, -1.1337448549999169e-03,
       8.4607239368243194e-03, 1.1428835231309651e-03,
       9.9996355431971484e-01 ]
projection_matrix:
   rows: 3
   cols: 4
   data: [ 2.8845847407434218e+02, 0., 4.2228301048278809e+02, 0., 0.,
       2.8845847407434218e+02, 4.0177149677276611e+02, 0., 0., 0., 1.,
       0. ]
```

### 启动矫正节点

```bash
ROS_NAMESPACE=camera rosrun stereo_image_proc stereo_image_proc \
left/image_raw:=fisheye1/image_raw \
right/image_raw:=fisheye2/image_raw \
left/camera_info:=fisheye1/camera_info_calib \
right/camera_info:=fisheye2/camera_info_calib
```

该节点会发布矫正后的图像和双目点云

## 启动RtabMap

最烦人的就是RtabMap的参数调整，很多参数感觉是重复的，又不知道应该在哪里指定
最终我尝试了使用矫正后的图像建图，然后直接拿OpenVins的里程计使用

```bash
roslaunch rtabmap_ros rtabmap.launch \
args:="-d" \
odom_args:="--Rtabmap/ImagesAlreadyRectified true" \
stereo:=true \
left_image_topic:=/camera/left/image_rect_color \
right_image_topic:=/camera/right/image_rect \
visual_odometry:=false \
odom_frame_id:=global \
approx_sync:=true \
left_camera_info_topic:=/camera/fisheye1/camera_info_calib \
right_camera_info_topic:=/camera/fisheye2/camera_info_calib
```

> visual_odometry:=false 不使用内置里程计
> left_image_topic:=/camera/left/image_rect_color 给到左眼彩色的矫正后图像，因为点云的构建需要用到彩色图像
> odom_frame_id:=global 告诉它使用的里程计的frame
> approx_sync:=true 因为消息之间会有时间差，即timestamp不同步，所以要使用这个选项异步运算  

这样就可以实现视觉的3DSLAM了